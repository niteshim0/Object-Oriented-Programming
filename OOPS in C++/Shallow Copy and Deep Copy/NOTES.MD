# Need of Copying Objects in C++

1. **Preventing Unitended Side Effects**: Copying objects ensures that changes made to one object do not affect other instances. Without proper copying mechanisms, modifying one object could inadvertently alter the data of another, leading to unintended side effects and unpredictable behavior.

2. **Passing objects by value**:When passing objects as function arguments in C++, you may choose to pass them by value to prevent unintended modifications to the original object. In such cases, creating a copy of the object is necessary to work with a local, independent instance within the function scope.

3. **Facilitating data manipulation**:Creating copies of objects allows for independent data manipulation. This is especially important when dealing with mutable data structures or when performing operations that require separate instances of the same object to be manipulated differently.

4. **Avoiding data inconsistency**: In scenarios where multiple instances of the same object are involved in different parts of the program, maintaining data consistency becomes essential. Creating copies ensures that each instance operates independently, preventing data inconsistencies that could arise from shared data access.

5. **Managing dynamic memory allocation**:When dealing with objects that contain dynamically allocated memory, such as pointers, creating copies helps manage memory effectively. By implementing deep copying mechanisms, you can ensure that each object has its own separate memory space, preventing issues like memory leaks or dangling pointers.

# How to create a Copy of Objects in C++?

Threre are two ways to create copy of Objects in C++:

1. **Copy Constructor**:

 - A copy constructor is a special constructor that is used to create a new object as a copy of an existing object. It is called when a new object is created based on an existing object, either by initialization or by passing it as a function argument by value. e.g, Dummy d1 = d2;
 - It takes a reference to an object of the same class as its parameter and performs a member-wise copy of the data members from the source object to the new object.
 - The copy constructor is responsible for creating a new object and initializing its data members by copying the values from the source object. If the object contains dynamically allocated memory, the copy constructor needs to ensure a deep copy to prevent both objects from sharing the same memory location.

2. **Assignment Operator**:

 - The assignment operator is used to copy the values from one object to another after both objects have already been initialized. It is invoked when you assign one object to another using the = operator.
 - It takes a reference to an object of the same class as its parameter and performs a similar member-wise copy of data members from the source object to the target object. Before performing the copy, it often checks for self-assignment to prevent unnecessary operations and memory leaks.
 - The assignment operator is responsible for copying the values of the data members from the source object to the target object. If the object contains dynamically allocated memory, the assignment operator should perform a deep copy to ensure that the two objects are independent of each other.


## Shallow Copy and Deep Copy

1. **Shallow Copy**:
  - Shallow copy is a simple member-wise copy of one object to another. 
  - When you perform a shallow copy, you copy the values of the data members from one object to another. 
  - If the object contains pointers or dynamically allocated memory, a shallow copy only copies the memory addresses, not the actual data. As a result, both the original and the copied object may end up pointing to the same memory location. Consequently, changes made to the data through one object may affect the other.
- Shallow copying can be done by the default copy constructor and assignment operator generated by the compiler.

2. **Deep Copy**:
 
 - Deep copy, on the other hand, involves creating a new object and then copying the values of the data members from the source object to the new object. 
 - If the object contains dynamically allocated memory, a deep copy allocates new memory for the target object and copies the contents to the new memory location. This ensures that the original and the copied object are completely independent, and changes made to one do not affect the other.
 - You have to implement your own copy constructor and assignment operator to ensure a deep copy.
 - If not implemented created , it leads to problem of dangling pointer.

# Memory Leaks and Dangling Pointer

 1. **Memory Leak**:
  - A memory leak occurs when a program allocates memory from the system (typically using functions like new or malloc) but fails to release or deallocate that memory when it is no longer needed.
  - Memory leaks can accumulate over time, causing the program's memory usage to grow continually. This can lead to performance degradation, increased resource consumption, and eventually, the program may run out of memory and crash.
  - Memory leaks are a common source of software bugs and can be challenging to identify and fix, as they often result from a failure to release memory in specific code paths, such as error conditions or exceptional situations.

2. **Dangling Pointers**:
  - A dangling pointer is a pointer that continues to point to a memory location after the memory it references has been deallocated or freed. Accessing a dangling pointer can result in undefined behavior and crashes, as the memory it points to may no longer be valid.
  - Dangling pointers often occur when pointers are used to reference memory that was allocated dynamically but later released using delete, free, or similar functions, making the pointer invalid.
  - Dangling pointers can be challenging to debug because the program may appear to work correctly in some cases but crash unpredictably in others, depending on whether the pointer is used after the memory is freed.


 








 
